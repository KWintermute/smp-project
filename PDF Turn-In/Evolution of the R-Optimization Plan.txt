The Evolutions of the R-Optimization Project Plan

At the start we began mostly just trying to learn how to work with R and about the libraries already available (so that we wouldn't have to code our own R compatible C Matrix math library from scratch). We had a schedule for how soon we'd know what and get what done and we had an online meeting every Friday so that assignments could be given out. We figured that after we knew how to integrate the C we wrote it'd be a simple matter of just hammering through a finite number of methods and individual assignments (both to figure out how to get things to work) and to get specific methods done would work fine.

We were all somewhat puzzled by the lack of code or apparent work needed as the code we were given was small and the test case ran in less than 2 seconds but aside from checking with the customer to make sure that there wasn't more (and he didn't give us more when we asked) we didn't worry much about it.

The obstacles we encountered initially were mostly in the requirement for training our members. Various people would go out and figure out various things about the project but conveying this information over Google Hangouts wasn't always easy, also a few of our members were new to github and thus sharing code was a bit awkward. To deal with these issues we also started meeting briefly after class so we could show more directly the things we'd learned.

We actually followed the plan pretty much exactly as we'd planned out in our schedule, until we got to the testing phase. Around this time we were able to get some real test cases from Major Freels along with a bunch of extra code (despite us asking him at the start if we had everything). When we started testing, it became very clear to us that what we were doing would barely help the codes speed. At this point our plan changed and we tried to find other ways to optimize the code. For this stage we started meeting in person and began a more intense collaboration than we had done with the individual assignments we'd handed out before. We were able to explore several options in the short time before our presentation.

Since our presentation, we've mostly just expanded on a few options that seemed most promising since then with the bulk of the actual work falling on those who came up with those solutions in the first place. Our communication with the customer is still somewhat slow which is a problem as some of our solutions are only viable depending on what he needs (for instance, if he just wants a graph drawn quickly during a presentation then our code which cuts down on the number of data points calculated could be very useful but if he actually needs the data then it defeats the purpose).

As it stands, so long as the goal is just to generate a graph that isn't too rough, we have code that can cut the render time down from 8+ minutes to a few seconds. If the goal is the data we can still cut the generation time down from 8+ minutes to 3+.